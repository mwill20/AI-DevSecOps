import { SecurityViolation, SecurityOverride, SecurityJustification, ValidationResult, CheckpointResult, Phase, ScanScope, ProjectContext } from '../types/SecurityViolation';
import { AuditLogger, getAuditLogger } from './AuditLogger';

export interface SecurityValidatorConfig {
  scanScope: ScanScope;
  realTimeStreaming: boolean;
  overrideAuthority: 'self' | 'peer' | 'security';
  auditLogging: boolean;
  enableBackgroundScanning: boolean;
  maxScanDuration: number; // in seconds
}

export interface ScanContext {
  projectPath: string;
  phase: Phase;
  developerId: string;
  modifiedFiles: string[];
  agentSource?: string;
}

class SecurityValidator {
  private config: SecurityValidatorConfig;
  private auditLogger: AuditLogger;
  private isScanning: boolean = false;
  private currentScan: Promise<ValidationResult> | null = null;

  constructor(config: SecurityValidatorConfig) {
    this.config = config;
    this.auditLogger = getAuditLogger();
  }

  // Core validation workflow
  async validatePhaseTransition(
    fromPhase: Phase, 
    toPhase: Phase, 
    projectContext: ProjectContext
  ): Promise<ValidationResult> {
    if (this.isScanning) {
      throw new Error('Security scan already in progress');
    }

    const startTime = Date.now();
    
    try {
      this.isScanning = true;
      
      // Log scan start
      await this.auditLogger.logScanStart(
        projectContext.developerId, 
        projectContext.path, 
        projectContext.agentSource
      );

      // Perform the scan
      const violations = await this.performSecurityScan(projectContext);
      
      const scanDuration = Date.now() - startTime;
      
      // Log scan completion
      await this.auditLogger.logScanComplete(
        projectContext.developerId,
        violations.length,
        scanDuration
      );

      // Determine if transition is allowed
      const hasBlockingViolations = violations.some(v => 
        v.severity === 'CRITICAL' || v.severity === 'HIGH'
      );
      
      const canProceed = !hasBlockingViolations || violations.every(v => v.override);

      const result: ValidationResult = {
        passed: violations.length === 0,
        violations,
        scanDuration,
        canProceed,
        requiresOverride: hasBlockingViolations
      };

      return result;

    } finally {
      this.isScanning = false;
    }
  }

  // Real-time scanning
  async startRealTimeScan(projectPath: string): Promise<void> {
    if (!this.config.realTimeStreaming) {
      return;
    }

    // This would integrate with file system watchers
    // For now, we'll implement a placeholder
    console.log(`Starting real-time scan for ${projectPath}`);
  }

  async scanFile(filePath: string, content?: string): Promise<SecurityViolation[]> {
    // Placeholder for individual file scanning
    // This would integrate with the ScanEngine
    console.log(`Scanning file: ${filePath}`);
    return [];
  }

  // Override management
  async processOverride(
    violationId: string, 
    justification: SecurityJustification,
    developerId: string
  ): Promise<SecurityOverride> {
    const override: SecurityOverride = {
      id: this.generateId(),
      violationId,
      justification,
      developerId,
      digitalSignature: '', // Will be generated by AuditLogger
      approvedAt: new Date(),
      auditLogEntry: '' // Will be set by AuditLogger
    };

    // Log the override (this will generate digital signature)
    await this.auditLogger.logOverride(override, developerId);

    return override;
  }

  // Security checkpoint modal
  async showSecurityCheckpoint(
    violations: SecurityViolation[],
    projectContext: ProjectContext
  ): Promise<CheckpointResult> {
    // This would integrate with the Terminal UI
    // For now, we'll return a basic result
    const hasBlockingViolations = violations.some(v => 
      v.severity === 'CRITICAL' || v.severity === 'HIGH'
    );

    return {
      action: hasBlockingViolations ? 'FIX_VIOLATIONS' : 'PROCEED',
      violations,
      overrides: violations.filter(v => v.override)
    };
  }

  // Private methods

  private async performSecurityScan(projectContext: ProjectContext): Promise<SecurityViolation[]> {
    const violations: SecurityViolation[] = [];
    
    // This would integrate with the ScanEngine
    // For now, we'll simulate some violations for testing
    
    if (projectContext.agentSource === 'windsurf') {
      // Simulate some common Windsurf-generated violations
      violations.push(this.createMockViolation(
        'LLM06',
        'HIGH',
        'Sensitive Information Disclosure',
        'Hardcoded API key detected in generated code',
        'src/config/api.ts',
        15,
        'const API_KEY = "sk-1234567890abcdef";',
        'Move API key to environment variables and use process.env.API_KEY',
        'CWE-798',
        projectContext.agentSource
      ));
    }

    if (projectContext.agentSource === 'anti-gravity') {
      // Simulate Anti-Gravity experimental code violations
      violations.push(this.createMockViolation(
        'LLM02',
        'MEDIUM',
        'Insecure Output Handling',
        'Raw LLM output displayed without sanitization',
        'src/components/ChatOutput.tsx',
        42,
        '<div>{llmResponse}</div>',
        'Sanitize LLM output using DOMPurify or similar before rendering',
        'CWE-79',
        projectContext.agentSource
      ));
    }

    // Log each violation
    for (const violation of violations) {
      await this.auditLogger.logViolation(violation, projectContext.agentSource);
    }

    return violations;
  }

  private createMockViolation(
    category: string,
    severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',
    title: string,
    description: string,
    file: string,
    line: number,
    codeSnippet: string,
    recommendation: string,
    cweReference?: string,
    agentSource?: string
  ): SecurityViolation {
    return {
      id: this.generateId(),
      severity,
      category,
      title,
      description,
      file,
      line,
      codeSnippet,
      recommendation,
      cweReference,
      agentSource,
      status: 'OPEN',
      discoveredAt: new Date()
    };
  }

  private generateId(): string {
    return `violation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Public utility methods

  async getSecurityScore(projectContext: ProjectContext): Promise<number> {
    // Calculate security score based on recent violations
    const recentEvents = await this.auditLogger.getAuditHistory(100);
    const recentViolations = recentEvents.filter(e => e.eventType === 'VIOLATION_FOUND');
    
    // Simple scoring: 100 - (5 * critical) - (3 * high) - (1 * medium)
    let score = 100;
    for (const violation of recentViolations) {
      const severity = violation.data.violation?.severity;
      if (severity === 'CRITICAL') score -= 5;
      else if (severity === 'HIGH') score -= 3;
      else if (severity === 'MEDIUM') score -= 1;
    }
    
    return Math.max(0, score);
  }

  async getSecurityStats(projectContext: ProjectContext): Promise<{
    totalViolations: number;
    criticalViolations: number;
    highViolations: number;
    overridesCount: number;
    lastScanDate: Date | null;
    securityScore: number;
  }> {
    const auditStats = await this.auditLogger.getAuditStats();
    const securityScore = await this.getSecurityScore(projectContext);
    
    return {
      totalViolations: auditStats.violationCount,
      criticalViolations: 0, // Would need to parse violation details
      highViolations: 0, // Would need to parse violation details
      overridesCount: auditStats.overrideCount,
      lastScanDate: auditStats.lastScan,
      securityScore
    };
  }

  // Configuration management
  updateConfig(newConfig: Partial<SecurityValidatorConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }

  getConfig(): SecurityValidatorConfig {
    return { ...this.config };
  }

  // Health check
  async healthCheck(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    auditLogIntegrity: boolean;
    lastScan: Date | null;
    isScanning: boolean;
  }> {
    const auditIntegrity = await this.auditLogger.verifyAuditIntegrity();
    const auditStats = await this.auditLogger.getAuditStats();
    
    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
    
    if (!auditIntegrity) {
      status = 'unhealthy';
    } else if (this.isScanning) {
      status = 'degraded';
    }
    
    return {
      status,
      auditLogIntegrity,
      lastScan: auditStats.lastScan,
      isScanning: this.isScanning
    };
  }
}

export default SecurityValidator;
